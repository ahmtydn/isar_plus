---
title: Migrate from Isar v3
description: Complete guide to migrating from Isar 3.x to Isar Plus v4
icon: ArrowRightLeft
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Steps } from 'fumadocs-ui/components/steps';

# Migrate from Isar v3 to Isar Plus v4

Upgrading from the legacy `isar` 3.x packages to `isar_plus` (v4) is a **breaking, file-format change**. The v4 core writes different metadata and cannot open a database that was written by v3, so you see errors such as:

```
VersionError: The database version is not compatible with this version of Isar.
```

The fix is to export your existing data with the legacy runtime and import it into a fresh Isar Plus database. The steps below walk you through the process.

## Migration Overview

<Steps>
### Keep Legacy Build

Ship (or keep) a build that still depends on `isar:^3.1.0+1` so you can read the legacy files.

### Add Isar Plus

Add `isar_plus` and `isar_plus_flutter_libs` next to the legacy packages while you migrate.

### Regenerate Schemas

Re-run the code generator so your schemas compile against the v4 APIs.

### Copy Data

Copy every record from the v3 instance into a brand-new Isar Plus instance.

### Clean Up

Delete the legacy files and remove the old dependencies once the copy succeeds.
</Steps>

<Callout type="info" title="Fresh Start">
If you do **not** need the old data, you can simply delete the v3 directory and start with a fresh database. The remainder of this guide focuses on preserving existing records.
</Callout>

## Update Dependencies Side by Side

Keep the old runtime until the copy finishes, then add the new one:

```yaml title="pubspec.yaml"
dependencies:
  isar: ^3.1.0+1
  isar_flutter_libs: ^3.1.0+1
  isar_generator: ^3.1.0+1
  isar_plus: ^1.1.5
  isar_plus_flutter_libs: ^1.1.5

dev_dependencies:
  build_runner: ^2.4.10
```

The two packages expose the same Dart symbols, so always import them with aliases during migration:

```dart title="imports.dart"
import 'package:isar/isar.dart' as legacy;
import 'package:isar_plus/isar_plus.dart' as plus;
```

## Regenerate Your Schemas for v4

Isar Plus ships its generator inside the main package. Re-run the builder so it emits the new helpers and adapters:

```bash
dart run build_runner build --delete-conflicting-outputs
```

Pause here and address any compilation errors (for example, nullable `Id?` fields must become non-nullable `int id` or use `Isar.autoIncrement`).

### API Migration Guide Key Changes

<Tabs items={['Transactions', 'IDs', 'Enums', 'Links']}>
<Tab value="Transactions">
**Old (v3):**
```dart
await isar.writeTxn(() async {
  await isar.users.put(user);
});
```

**New (v4):**
```dart
await isar.writeAsync((isar) async {
  await isar.users.put(user);
});
```
</Tab>

<Tab value="IDs">
**Old (v3):**
```dart
@collection
class User {
  Id? id; // nullable
}
```

**New (v4):**
```dart
@collection
class User {
  int id = Isar.autoIncrement; // or @id
}
```
</Tab>

<Tab value="Enums">
**Old (v3):**
```dart
@enumerated
enum Status { active, inactive }
```

**New (v4):**
```dart
@enumValue
enum Status { active, inactive }
```
</Tab>

<Tab value="Links">
**Old (v3):**
```dart
final posts = IsarLinks<Post>();
```

**New (v4):**
```dart
// Use embedded objects instead
List<Post> posts = [];
```
</Tab>
</Tabs>

## Copy the Actual Data

Create a one-off migration routine (for example in `main()` before initializing your app, or in a separate `bin/migrate.dart`). The pattern is:

1. Open the legacy store with the v3 runtime
2. Open a new v4 instance in a different directory or under a different name
3. Page through each collection, map it to the new schema, and `put` it into the new database
4. Mark the migration as finished so you do not run it twice

```dart title="migration.dart"
Future<void> migrateLegacyDb(String directoryPath) async {
  final legacyDb = await legacy.Isar.open(
    [LegacyUserSchema, LegacyTodoSchema],
    directory: directoryPath,
    inspector: false,
    name: 'legacy',
  );

  final plusDb = await plus.Isar.open(
    [UserSchema, TodoSchema],
    directory: directoryPath,
    name: 'app_v4',
    engine: plus.IsarEngine.sqlite, // or IsarEngine.isar for native
    inspector: false,
  );

  await _copyUsers(legacyDb, plusDb);
  await _copyTodos(legacyDb, plusDb);

  await legacyDb.close();
  await plusDb.close();
}

Future<void> _copyUsers(legacy.Isar legacyDb, plus.Isar plusDb) async {
  const pageSize = 200;
  final total = await legacyDb.legacyUsers.count();

  for (var offset = 0; offset < total; offset += pageSize) {
    final batch = await legacyDb.legacyUsers
      .where()
      .offset(offset)
      .limit(pageSize)
      .findAll();
      
    await plusDb.writeAsync((isar) async {
      await isar.users.putAll(
        batch.map((user) => User(
          id: user.id ?? plus.Isar.autoIncrement,
          email: user.email,
          status: _mapStatus(user.status),
        )),
      );
    });
  }
}
```

<Callout type="info" title="Mapping Helper">
Keep the mapping methods (`_mapStatus` in the snippet) next to the migration routine so you can handle enum renames, field removals, or any data cleanup in one place.
</Callout>

If you have very large collections, run the loop inside an isolate or background service to avoid blocking the UI. The same pattern works for embedded objects and linksâ€”load them with the legacy query API, then persist them with the new schema.

## Make Sure It Only Runs Once

Shipping both runtimes means every cold start could try to migrate again unless you gate it behind a flag. Persist a migration version so the copy runs only once per installation:

```dart title="migration_tracker.dart"
class MigrationTracker {
  static const key = 'isarPlusMigration';

  static Future<bool> needsMigration() async {
    final prefs = await SharedPreferences.getInstance();
    return !prefs.getBool(key).toString().contains('true');
  }

  static Future<void> markDone() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(key, true);
  }
}

Future<void> bootstrapIsar(String dir) async {
  if (await MigrationTracker.needsMigration()) {
    await migrateLegacyDb(dir);
    await MigrationTracker.markDone();
  }

  final isar = await plus.Isar.open(
    [UserSchema, TodoSchema],
    directory: dir,
  );

  runApp(MyApp(isar: isar));
}
```

<Callout type="info" title="Alternative Approaches">
Instead of a boolean you can store a numeric schema version (for example `3` for legacy, `4` for Isar Plus) if you anticipate future migrations. On desktop or server builds you can also write a tiny `.migrated` file next to the database directory instead of using shared preferences.
</Callout>

## Clean Up

After every collection finishes copying:

<Steps>
### Persist Flag

Mark migration as complete:
```dart
await prefs.setBool('migratedToIsarPlus', true);
```

### Delete Legacy Files

Remove old database files:
```dart
await plus.Isar.deleteDatabase(
  name: 'legacy',
  directory: directoryPath,
  engine: plus.IsarEngine.isar,
);
```

### Remove Dependencies

Update `pubspec.yaml` to remove `isar` and `isar_flutter_libs`.

### Rename Database

Optionally rename the new database back to your original name.
</Steps>

Only when you are confident that users no longer open the legacy build should you ship an update that depends solely on `isar_plus`.

## Troubleshooting

### VersionError Persists

<Callout type="error" title="Solution">
Double-check that you deleted the v3 files before opening the v4 instance. Old WAL/LCK files can keep the legacy header around.
</Callout>

### Duplicate Primary Keys

<Callout type="warn" title="ID Requirements">
Remember that v4 IDs must be unique, non-null integers. Use `Isar.autoIncrement` or generate your own deterministic keys while copying.
</Callout>

### Generator Fails

Run cleanup before building:
```bash
dart pub clean
dart run build_runner build --delete-conflicting-outputs
```

Ensure no `part '...g.dart';` directives are missing.

### Need to Rollback

<Callout type="info" title="Safe Migration">
Because the migration writes into a separate database, you can safely discard the new files and keep the legacy ones until the copy completes.
</Callout>

Once these steps are in place, users can upgrade directly from an `isar` 3.x build to an `isar_plus` release without data loss.
