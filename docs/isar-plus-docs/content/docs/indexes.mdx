---
title: Indexes
description: Optimize query performance with powerful indexing strategies
icon: Zap
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';
import { Steps } from 'fumadocs-ui/components/steps';

# Indexes

Indexes are Isar's most powerful feature for query optimization. Learn how to use single, composite, and multi-entry indexes effectively.

<Callout type="success">
  Understanding indexes is essential to optimize query performance!
</Callout>

## What are Indexes?

Without indexes, queries must scan through every object linearly. With indexes, queries can jump directly to the relevant data.

### Example Without Index

```dart
@collection
class Product {
  Id? id;
  late String name;
  late int price;
}
```

**Unindexed Data:**

| id | name | price |
| --- | --- | --- |
| 1 | Book | 15 |
| 2 | Table | 55 |
| 3 | Chair | 25 |
| 4 | Pencil | 3 |
| 5 | Lightbulb | 12 |
| 6 | Carpet | 60 |
| 7 | Pillow | 30 |
| 8 | Computer | 650 |
| 9 | Soap | 2 |

To find products > €30, Isar must check all 9 rows:

```dart
final expensive = await isar.products.filter()
  .priceGreaterThan(30)
  .findAll();
```

### With Index

Add an index to the `price` field:

```dart
@collection
class Product {
  Id? id;
  late String name;
  
  @Index()
  late int price;
}
```

**Generated Index (sorted):**

| price | id |
| --- | --- |
| 2 | 9 |
| 3 | 4 |
| 12 | 5 |
| 15 | 1 |
| 25 | 3 |
| 30 | 7 |
| **55** | **2** |
| **60** | **6** |
| **650** | **8** |

Now the query jumps directly to the relevant rows! ⚡

## Creating Indexes

### Single Property Index

```dart
@collection
class User {
  Id? id;

  @Index()
  late String email;

  @Index(type: IndexType.value)
  late String username;
}
```

<Tabs items={['IndexType.value', 'IndexType.hash', 'IndexType.hashElements']}>
  <Tab value="IndexType.value">
    **Default** - Stores the actual value. Supports all where clauses.
    ```dart
    @Index(type: IndexType.value)
    late String email;
    
    // Supports: equalTo, between, startsWith, etc.
    await isar.users.where()
      .emailStartsWith('john')
      .findAll();
    ```
  </Tab>
  <Tab value="IndexType.hash">
    Stores hash of value. Only supports equality checks. Uses less space.
    ```dart
    @Index(type: IndexType.hash)
    late String email;
    
    // Only supports: equalTo
    await isar.users.where()
      .emailEqualTo('john@example.com')
      .findAll();
    ```
  </Tab>
  <Tab value="IndexType.hashElements">
    For Lists only. Hashes each element individually.
    ```dart
    @Index(type: IndexType.hashElements)
    late List<String> tags;
    
    await isar.posts.where()
      .tagsElementEqualTo('flutter')
      .findAll();
    ```
  </Tab>
</Tabs>

### Composite Indexes

Index multiple properties together for complex queries:

```dart
@collection
class Person {
  Id? id;

  late String firstName;

  @Index(composite: [CompositeIndex('firstName')])
  late String lastName;

  late int age;
}
```

```dart
// Uses composite index efficiently
final people = await isar.persons
  .where()
  .lastNameFirstNameEqualTo('Doe', 'John')
  .findAll();
```

<Callout type="info">
  Composite indexes can also use only the first property: `.lastNameEqualTo('Doe')`
</Callout>

### Multi-Property Composite

```dart
@collection
@Index(composite: [
  CompositeIndex('lastName'),
  CompositeIndex('age')
])
class Person {
  Id? id;
  late String firstName;
  late String lastName;
  late int age;
}
```

```dart
// All of these use the composite index:
.firstNameEqualTo('John')
.firstNameLastNameEqualTo('John', 'Doe')
.firstNameLastNameAgeEqualTo('John', 'Doe', 25)
```

## Multi-Entry Indexes

Create indexes for list elements:

```dart
@collection
class Post {
  Id? id;

  late String title;

  @Index(type: IndexType.value)
  late List<String> tags;
}
```

```dart
// Fast lookup by any tag
final flutterPosts = await isar.posts
  .where()
  .tagsElementEqualTo('flutter')
  .findAll();
```

<Callout type="warning">
  Multi-entry indexes can significantly increase database size for lists with many elements.
</Callout>

## Unique Indexes

Enforce uniqueness constraints:

```dart
@collection
class User {
  Id? id;

  @Index(unique: true)
  late String username;

  late int age;
}
```

```dart
final user1 = User()
  ..username = 'john_doe'
  ..age = 25;
await isar.users.put(user1); // ✅ OK

final user2 = User()
  ..username = 'john_doe'
  ..age = 30;
await isar.users.put(user2); // ❌ Error: unique constraint violated
```

<Callout type="error">
  Attempting to insert duplicate values will throw an error.
</Callout>

## Replace Indexes

Auto-replace objects on unique constraint violation:

```dart
@collection
class User {
  Id? id;

  @Index(unique: true, replace: true)
  late String username;

  late int age;
}
```

```dart
final user1 = User()
  ..id = 1
  ..username = 'john_doe'
  ..age = 25;
await isar.users.put(user1);
print(await isar.users.where().findAll());
// [{id: 1, username: 'john_doe', age: 25}]

final user2 = User()
  ..id = 2
  ..username = 'john_doe'
  ..age = 30;
await isar.users.put(user2);
print(await isar.users.where().findAll());
// [{id: 2, username: 'john_doe', age: 30}]
```

### PutBy Methods

Replace indexes generate helper methods:

```dart
final user = User()
  ..username = 'john_doe'
  ..age = 25;

// Insert or update by username
await isar.users.putByUsername(user);

// The existing id is reused
final user2 = User()
  ..username = 'john_doe'
  ..age = 30;
await isar.users.putByUsername(user2);
// Same id as user, just updated age
```

## Case Sensitivity

Control case sensitivity for string indexes:

```dart
@collection
class User {
  Id? id;

  @Index(caseSensitive: false)
  late String email;
}
```

```dart
// Both find the same user
await isar.users.where().emailEqualTo('JOHN@example.com').findAll();
await isar.users.where().emailEqualTo('john@example.com').findAll();
```

<Callout>
  Case-insensitive indexes take slightly more space but provide flexible queries.
</Callout>

## Index for Sorting

Indexes provide super-fast sorting:

```dart
@collection
class Product {
  Id? id;

  late String name;

  @Index()
  late int price;
}
```

<Tabs items={['Without Index', 'With Index']}>
  <Tab value="Without Index">
    ```dart
    // ❌ Slow - loads all, then sorts
    final cheapest = await isar.products
      .filter()
      .sortByPrice()
      .limit(4)
      .findAll();
    ```
  </Tab>
  <Tab value="With Index">
    ```dart
    // ✅ Fast - uses sorted index
    final cheapest = await isar.products
      .where()
      .anyPrice()
      .limit(4)
      .findAll();
    ```
  </Tab>
</Tabs>

<Callout type="success">
  Using indexed sorting avoids loading and sorting all results in memory!
</Callout>

## Where Clauses

Use indexes with where clauses for maximum performance:

```dart
@collection
class Product {
  Id? id;

  late String name;

  @Index()
  late int price;
}
```

```dart
// Fast - uses index
final products = await isar.products
  .where()
  .priceBetween(10, 100)
  .findAll();

// Fast - index + sort
final sorted = await isar.products
  .where()
  .anyPrice()
  .limit(10)
  .findAll();

// Fast - index + filter
final filtered = await isar.products
  .where()
  .priceGreaterThan(50)
  .filter()
  .nameStartsWith('iPhone')
  .findAll();
```

## Index Types Comparison

| Type | Size | Where Clauses | Use Case |
| --- | --- | --- | --- |
| `IndexType.value` | Large | All | Full text search, ranges |
| `IndexType.hash` | Small | Equality only | Unique constraints, lookups |
| `IndexType.hashElements` | Medium | List elements | Tag systems, categories |

## Best Practices

<Steps>

### Choose the Right Properties

Index properties used frequently in where clauses:

```dart
@collection
class User {
  Id? id;

  @Index() // Frequently queried
  late String email;

  late String name; // Not indexed - rarely queried alone
}
```

### Don't Over-Index

Each index increases write time and storage:

```dart
// ❌ Too many indexes
@collection
class User {
  @Index() Id? id; // Id is already indexed!
  @Index() late String email;
  @Index() late String name;
  @Index() late String phone;
  @Index() late int age;
}

// ✅ Index only what you query
@collection
class User {
  Id? id;
  @Index(unique: true) late String email;
  late String name;
  late String phone;
  late int age;
}
```

### Use Composite Indexes Wisely

```dart
// ✅ Good - queries firstName + lastName together
@Index(composite: [CompositeIndex('lastName')])
late String firstName;

// ❌ Bad - separate queries
@Index()
late String firstName;
@Index()
late String lastName;
```

### Profile Your Queries

Use Isar Inspector to analyze query performance:

```dart
// Enable inspector in debug mode
final isar = await Isar.open(
  [UserSchema],
  inspector: true, // Open inspector
);
```

</Steps>

## Index Limitations

<Callout type="warning">
  - Only the first 1024 bytes of strings are indexed
  - Maximum of 3 properties in composite indexes (on web)
  - Indexes increase write operation time
  - Indexes consume additional storage
</Callout>

## Next Steps

<Cards>
  <Card title="Queries" href="/docs/queries">
    Learn how to use indexes in queries
  </Card>
  <Card title="Full-Text Search" href="/docs/recipes/full_text_search">
    Implement search functionality
  </Card>
  <Card title="Performance" href="/docs/recipes">
    Optimization techniques
  </Card>
</Cards>
